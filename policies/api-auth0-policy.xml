<policies>
    <inbound>
        <base />
        <!-- Extract JWT token from Authorization header -->
        <set-variable name="jwt-token" value="@{
            var authHeader = context.Request.Headers.GetValueOrDefault("Authorization", "");
            return authHeader.StartsWith("Bearer ") ? authHeader.Substring(7) : "";
        }" />
        
        <!-- Validate JWT token with Auth0 -->
        <validate-jwt 
            header-name="Authorization" 
            failed-validation-httpcode="401" 
            failed-validation-error-message="Unauthorized: Invalid or missing JWT token"
            require-expiration-time="true" 
            require-scheme="Bearer" 
            require-signed-tokens="true">
            <openid-config url="{{auth0-domain}}/.well-known/openid-configuration" />
            <audiences>
                <audience>{{auth0-audience}}</audience>
            </audiences>
            <issuers>
                <issuer>{{auth0-domain}}/</issuer>
            </issuers>
            <required-claims>
                <claim name="scope" match="any">
                    <value>read:api</value>
                    <value>write:api</value>
                </claim>
            </required-claims>
        </validate-jwt>
        
        <!-- Extract claims from JWT for downstream use -->
        <set-variable name="user-id" value="@{
            var jwt = context.Request.Headers.GetValueOrDefault("Authorization", "").Replace("Bearer ", "");
            if (string.IsNullOrEmpty(jwt)) return "";
            
            try {
                var base64 = jwt.Split('.')[1];
                base64 = base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '=');
                var jsonBytes = Convert.FromBase64String(base64);
                var json = System.Text.Encoding.UTF8.GetString(jsonBytes);
                var claims = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, object>>(json);
                return claims.ContainsKey("sub") ? claims["sub"].ToString() : "";
            }
            catch {
                return "";
            }
        }" />
        
        <!-- Rate limiting per user -->
        <rate-limit-by-key 
            calls="100" 
            renewal-period="60" 
            counter-key="@(context.Variables.GetValueOrDefault<string>("user-id", "anonymous"))" 
            increment-condition="@(context.Response.StatusCode >= 200 && context.Response.StatusCode < 300)" />
        
        <!-- Quota per subscription -->
        <quota-by-key 
            calls="10000" 
            renewal-period="86400" 
            counter-key="@(context.Subscription?.Id ?? "anonymous")" />
        
        <!-- Add correlation ID for tracking -->
        <set-header name="X-Correlation-Id" exists-action="skip">
            <value>@(Guid.NewGuid().ToString())</value>
        </set-header>
        
        <!-- Add user context header for backend -->
        <set-header name="X-User-Id" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault<string>("user-id", ""))</value>
        </set-header>
        
        <!-- Set backend timeout -->
        <set-backend-service base-url="{{backend-url}}" />
        
        <!-- Cache GET requests for 5 minutes -->
        <cache-lookup vary-by-developer="false" vary-by-developer-groups="false" downstream-caching-type="none">
            <vary-by-header>Accept</vary-by-header>
            <vary-by-header>Accept-Charset</vary-by-header>
            <vary-by-query-parameter>*</vary-by-query-parameter>
        </cache-lookup>
    </inbound>
    
    <backend>
        <base />
        <!-- Retry policy with exponential backoff -->
        <retry 
            condition="@(context.Response.StatusCode >= 500 || context.Response.StatusCode == 429)" 
            count="3" 
            interval="1" 
            delta="1" 
            max-interval="10" 
            first-fast-retry="true">
            <forward-request buffer-request-body="true" timeout="30" />
        </retry>
    </backend>
    
    <outbound>
        <base />
        <!-- Cache successful GET responses -->
        <cache-store duration="300" />
        
        <!-- Add security headers -->
        <set-header name="X-Content-Type-Options" exists-action="override">
            <value>nosniff</value>
        </set-header>
        <set-header name="X-Frame-Options" exists-action="override">
            <value>DENY</value>
        </set-header>
        <set-header name="X-XSS-Protection" exists-action="override">
            <value>1; mode=block</value>
        </set-header>
        <set-header name="Strict-Transport-Security" exists-action="override">
            <value>max-age=31536000; includeSubDomains</value>
        </set-header>
        <set-header name="Content-Security-Policy" exists-action="override">
            <value>default-src 'self'</value>
        </set-header>
        
        <!-- Remove sensitive backend headers -->
        <set-header name="X-Powered-By" exists-action="delete" />
        <set-header name="X-AspNet-Version" exists-action="delete" />
        <set-header name="Server" exists-action="delete" />
        
        <!-- Add CORS headers if needed -->
        <cors allow-credentials="false">
            <allowed-origins>
                <origin>https://app.contoso.com</origin>
            </allowed-origins>
            <allowed-methods>
                <method>GET</method>
                <method>POST</method>
                <method>PUT</method>
                <method>DELETE</method>
                <method>PATCH</method>
            </allowed-methods>
            <allowed-headers>
                <header>*</header>
            </allowed-headers>
            <expose-headers>
                <header>*</header>
            </expose-headers>
        </cors>
    </outbound>
    
    <on-error>
        <base />
        <!-- Log errors -->
        <trace source="api-policy-error" severity="error">
            <message>@{
                return new JObject(
                    new JProperty("correlationId", context.RequestId),
                    new JProperty("error", context.LastError?.Message ?? "Unknown error"),
                    new JProperty("source", context.LastError?.Source ?? ""),
                    new JProperty("path", context.Request.Url.Path)
                ).ToString();
            }</message>
        </trace>
        
        <!-- Return standardized error response -->
        <return-response>
            <set-status code="@(context.Response?.StatusCode ?? 500)" reason="@(context.Response?.StatusReason ?? "Internal Server Error")" />
            <set-header name="Content-Type" exists-action="override">
                <value>application/json</value>
            </set-header>
            <set-body>@{
                return new JObject(
                    new JProperty("error", new JObject(
                        new JProperty("code", context.Response?.StatusCode ?? 500),
                        new JProperty("message", context.LastError?.Message ?? "An error occurred processing your request"),
                        new JProperty("correlationId", context.RequestId),
                        new JProperty("timestamp", DateTime.UtcNow.ToString("o"))
                    ))
                ).ToString();
            }</set-body>
        </return-response>
    </on-error>
</policies>
